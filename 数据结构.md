

[toc]

# OOP（Object Oriented Programming）

面相对象程序设计

# 封装/继承/多态

封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别

继承，是指可以让某个类型的对象获得另一个类型的对象的属性和方法

多态，就是指一个类实例的相同方法在不同情形有不同表现形式

# 数组内交换

```swift
// method1
func swap1(_ array: inout [Int], a: Int, b: Int) {
    let temp = array[a]
    array[a] = array[b]
    array[b] = temp
}
// method2
func swap2(_ array: inout [Int], a: Int, b: Int) {
    array[a] = array[a] + array[b]
    array[b] = array[a] - array[b]
    array[a] = array[a] - array[b]
}
// method3
func swap3(_ array: inout [Int], a: Int, b: Int) {
    if array[a] == 0 || array[b] == 0 {
        swap1(&array, a: a, b: b)
    } else {
        array[a] ^= array[b]
        array[b] ^= array[a]
        array[a] ^= array[b]
    }
}
func swap4(_ array: inout [Int], a: Int, b: Int) {
    (array[a], array[b]) = (array[b], array[a])
}
var array: [Int] = [10, 20, 30]
swap3(&array, a: 0, b: 2)
print(array)// 30 20 10
```

# 树

| 名称     | 描述                            |
| -------- | ------------------------------- |
| 树的度   | 一棵树中最大的节点的度          |
| 树的高度 | 树中节点最大层次（根节点第1层） |

对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1

具有n个结点的完全二叉树的深度k为log2(n+1)向上取整

## 满二叉树

高度为h且有2^h^-1个节点的二叉树

## 完全二叉树

高度为h的二叉树，第1层到第h-1层满，第h层节点集中在最左边

先序遍历

递归(自身->左子树->右子树)

![在这里插入图片描述](https://img-blog.csdnimg.cn/202012091634524.gif#pic_center)

中序遍历

递归(左子树->自身->右子树)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201209164211397.gif#pic_center)

后续遍历

递归(左子树->右子树->自身)

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020120916532175.gif#pic_center)

![img](https://img-blog.csdn.net/20161006192605038?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

通过中序遍历和先序遍历可以确定一个树

先序遍历结果：ABDHKECFIGJ

中序遍历结果：HKDBEAIFCGJ

通过中序遍历和后续遍历可以确定一个树

中序遍历结果：HKDBEAIFCGJ

后序遍历结果：KHDEBIFJGCA

通过先序遍历和后序遍历不可以确定一个树

如何获取其中一个树？

## Huffman树

![img](https://img-blog.csdn.net/20170403090739080)

Huffman编码

![img](https://img-blog.csdn.net/20170403090916254)

Huffman解码

![img](https://img-blog.csdn.net/20170403091028446)

## B树（BalanceTree树）

每个节点存储多个元素,包含索引和数据;叶子节点都在同一层,具有相同深度

![img](https://camo.githubusercontent.com/3b7f642bc171e741f2a43f4f8b27e70eff4f9a9648022c27b4af479aa6c32e7c/68747470733a2f2f7374617469632e6c6f766562696c6962696c692e636f6d2f6d7973716c5f73756f79696e5f322e706e67)

## B+树

B树上改进,非叶子节点只包含索引，叶子节点存储索引和数据;叶子结点由双向链表连接(获取大范围,通过链表访问下一个叶子结点,不用在此根节点查询)

![img](https://camo.githubusercontent.com/e1a71d1c1b8a7a7eebdc3ca8ceaceab0fa7396555f92d11548bdea54995c953c/68747470733a2f2f7374617469632e6c6f766562696c6962696c692e636f6d2f6d7973716c5f73756f79696e5f342e706e67)

## 红黑树

1. 每个节点都有红色或黑色
2. 树的根始终是黑色的
3. 没有两个相邻的红色节点
4. 从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点

[插入X](https://zhuanlan.zhihu.com/p/79980618)

1. 将X标记为红色
2. X是根节点，则标记为黑色
3. X的父节点是红色，X也不是根节点
   1. X的父兄节点是红色
      1. 将X的父节点和父兄节点标记为黑色
      2. 将祖父节点标记为红色
      3. 重复2，3
   2. X的父兄节点是黑色
      1. 左左(X的父节点是祖父节点的左节点，X是父节点的左节点)
         1. X的祖父节点右旋
         2. X的前父节点和前祖父节点换色
      2. 左右
         1. X的父节点左旋
         2. X的父节点右旋
         3. X与前父节点换色
      3. 右右
         1. X的祖父节点左旋
         2. X的前父节点和前祖父节点换色
      4. 右左
         1. X的父节点右旋
         2. X的父节点左旋
         3. X与前父节点换色



删除节点X，替换节点Y(叶子节点)

1. Y是红色（index 2）
   1. 替换后，将Y颜色更改为X的颜色
2. Y是黑色
   1. Y是左节点
      1. Y的兄弟节点是红色
         1. Y的兄弟节点标记为黑色
         2. Y的父节点标记为红色
         3. Y的父节点左旋
         4. index 4
      2. Y的兄弟节点是黑色
         1. Y的兄弟节点的右子节点是红色（index 1）
            1. Y的兄弟节点的右节点标记为黑色
            2. Y的兄弟节点与Y的父节点颜色互换
            3. Y的父节点左旋
         2. Y的兄弟节点的右子节点是黑色，Y的兄弟节点的左子节点是红色
            1. Y的兄弟节点和Y的兄弟节点的左子节点颜色互换
            2. Y的兄弟节点右旋
            3. index 1
         3. Y的兄弟节点的子节点都是黑色（index 4）
            1. Y的兄弟节点标记为红色
            2. Y的父节点成为新的替换节点
            3. index 2
   2. Y是右节点
      1. Y的兄弟节点是红色
         1. Y的兄弟节点标记为黑色
         2. Y的父节点标记为红色
         3. Y的父节点右旋
         4. index 6
      2. Y的兄弟节点是黑色
         1. Y的兄弟节点的左子节点是红色（index 5）
            1. Y的兄弟节点的左节点标记为黑色
            2. Y的兄弟节点与Y的父节点颜色互换
            3. Y的父节点右旋
         2. Y的兄弟节点的左子节点是黑色，Y的兄弟节点的右子节点是红色
            1. Y的兄弟节点与Y的兄弟节点的右子节点颜色互换
            2. Y的兄弟节点左旋
            3. index 5
         3. Y的兄弟节点的子节点都是黑色（index 6）
            1. Y的兄弟节点标记为红色
            2. Y的父节点成为新的替换节点
            3. index 2

# 图

## 邻接矩阵

![在这里插入图片描述](https://img-blog.csdnimg.cn/202103011006555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70#pic_center)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210301101417729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70#pic_center)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210301110502994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70#pic_center)

## 邻接表

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210301165232511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70#pic_center)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210301165330914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70#pic_center)

## 深度遍历和广度遍历

[link]([200. 岛屿数量 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/number-of-islands/))

```java
public class Main {
    public static void main(String args[]) {
        int[][] grid = {
                {1,1,0,0,0},
                {1,1,0,0,0},
                {0,0,1,0,0},
                {0,0,0,1,1}
        };
        Method method = new Method();
        System.out.println(method.numIslands(grid));
    }
}
class Method {
    public int numIslands(int[][] grid) {
        int r = grid.length;
        if(r == 0)
            return 0;
        int c = grid[0].length, res = 0;
        for(int i = 0; i < r; i++) {
            for(int j = 0; j < c; j++)
                if (grid[i][j] == 1) {
                    res++;
                    BFSClear(grid, i, j);

                }
        }
        return res;
    }
    public void DFSClear(int[][] grid, int i, int j) {
        int r = grid.length, c = grid[0].length;
        if(i < 0 || j < 0 || i == r || j == c || grid[i][j] == 0)
            return ;
        grid[i][j] = 0;
        DFSClear(grid, i - 1, j);
        DFSClear(grid, i + 1, j);
        DFSClear(grid, i, j - 1);
        DFSClear(grid, i, j + 1);
    }
    private void BFSClear(int[][] grid, int i, int j) {
        int r = grid.length, c = grid[0].length;
        Queue<Integer> queue = new LinkedList<>();
        queue.add(i * c + j);
        while(!queue.isEmpty()) {
            int id = queue.poll();
            int x = id / c, y = id % c;
            grid[x][y] = 0;
            if(x - 1 >= 0 && grid[x - 1][y] == 1) {
                queue.add((x - 1) * c + y);
            }
            if(x + 1 < r && grid[x + 1][y] == 1) {
                queue.add((x + 1) * c + y);
            }
            if(y - 1 >= 0 && grid[x][y - 1] == 1) {
                queue.add(x * c + (y - 1));
            }
            if(y + 1 < c && grid[x][y + 1] == 1) {
                queue.add(x * c + (y + 1));
            }
        }
    }
}
```

## 最短路算法DIJKSTRA

将点分为已标号点集和未标号点集，从已标号点集中A到达未标号点集中B的**最短距离**，并将B纳入已标号点集

```java
public class Main {
    public static void main(String args[]) {
        int[][] dis = {
                {0, 2, 0, 3, 0, 0, 0, 0},// 0
                {2, 0, 3, 0, 4, 6, 0, 0},
                {0, 3, 0, 2, 0, 4, 0, 0},
                {3, 0, 2, 0, 0, 0, 4, 0},
                {0, 4, 0, 0, 0, 2, 0, 3},
                {0, 6, 4, 0, 2, 0, 3, 2},
                {0, 0, 0, 4, 0, 3, 0, 2},
                {0, 0, 0, 0, 3, 2, 2, 0}//
        };
        Dijkstra dijkstra = new Dijkstra();
        int min = dijkstra.minDis(dis, 0, 7);
        System.out.println(min);
    }
}
class Dijkstra {
    public int minDis(int[][] dis, int s, int t) {
        int r = dis.length;
        if(r == 0)
            return 0;
        int[] min = new int[r];
        Arrays.fill(min, Integer.MAX_VALUE);
        min[s] = 0;
        while(min[t] == Integer.MAX_VALUE) {
            int[] temp = new int[r];
            Arrays.fill(temp, Integer.MAX_VALUE);
            int minIndex = -1;
            for(int i = 0; i < r; i++) {
                if(min[i] != Integer.MAX_VALUE) {
                    // 从已到达的点出发
                    for(int j = 0; j < r; j++) {
                        if(dis[i][j] != 0 && min[j] == Integer.MAX_VALUE) {
                            // 有距离而且还未到达
                            temp[j] = Integer.min(temp[j], min[i] + dis[i][j]);
                            if(minIndex == -1)
                                minIndex = j;
                            else
                                minIndex = temp[minIndex] < temp[j] ? minIndex : j;
                        }
                    }
                }
            }
            min[minIndex] = temp[minIndex];
        }
        return min[t];
    }
}
```

# 堆

完全二叉树基础上，每个节点的值都小于其子节点称为最小堆，每个节点的值都大于其子节点称为最大堆；用数组实现，若满足$k_i \leqslant k_{2i+1} 且K_i \leqslant k_{2i+2}$称为最小堆，若满足$k_i \geqslant k_{2i+1} 且K_i \geqslant k_{2i+2}$称为最大堆$i=0,1,...i-1$

内存中的堆栈

栈区分配局部变量、临时变量的内存空间，栈的内存相对较少，递归层数太深会导致栈溢出，地址增长方向由高到低

堆区用于分配程序员申请的内存空间，需手动开辟、手动释放，地址增长方向由低到高
