## 三次握手

![在这里插入图片描述](https://img-blog.csdnimg.cn/eccf435f384041a69698b5ca18c30028.PNG?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAanVuMjAxNjQyNQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

![这里写图片描述](https://img-blog.csdn.net/20180809183055554?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bjIwMTY0MjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

第一次握手

客户端给服务器发送一个SYN段数据包，该段中包含初始序列号Sequence number = x，客户端状态转变为SYN_SEND

第二次握手

服务器返回客户端SYN +ACK段数据包，该段中包含初始序列号Sequence number = y，同时使 Acknowledgment number = x + 1来响应第一次握手，服务端状态转变为SYN_RCVD

第三次握手

客户端给服务器响应一个ACK段数据包，该段中使Acknowledgment number = y + 1来响应第二次握手，客户端状态转变为ESTABLISHED；服务端收到包后状态转变为ESTABLISHED

## 四次握手

![img](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

第一次握手

客户端向服务端发送FIN段的数据包，该段中包含初始序列号Sequence number = x，客户端状态转变为FIN-WAIT-1

第二次握手

服务端向客户端发送ACK段的数据包，该段中包含初始序列号Sequence number = u，Acknowledgement number = x + 1，服务端状态转变为CLOSE-WAIT；客户端收到数据包状态转变为FIN-WAIT-2

第三次握手

服务端向客户端发送FIN + ACK段的数据包，该段中包含初始序列号Sequence number = y，Acknowledge number = x + 1，服务端状态转变为LAST-ACK

第四次握手

客户端向服务端发送ACK段的数据包，该段中包含初始序列号Sequence number = x + 1，Acknowledge number = y + 1，客户端状态转变为TIME-WAIT，等待2MSL，状态再转变为CLOSED；服务端收到包后状态转变为CLOSED

## 其他问题

【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

## TCP和UDP

TCP是面相连接的，传输数据前必须先建立连接，数据传送后释放连接，全双工通信，而UDP不建立连接，面相报文

TCP提供可靠交付，按序到达，而UDP尽最大努力交付

TCP是单播形式，UDP是广播形式

## get和post

- get在浏览器回退时是无害的，而post会再次提交请求
- ~~get产生的url地址可以被Bookmark，而post不可以~~
- ~~get请求会被浏览器主动cache，而post不会，除非手动设置~~
- get请求只能进行url编码，而post支持多种编码方式
- ~~get请求参数会被完整保留在浏览器历是记录中，而post不会被保留~~
- get请求在url中传送的参数是有长度限制的，而post没有
- 对参数的数据类型，get只接受ASCLL字符，而post没有限制
- get比post更不安全，因为参数直接暴露在url上，所以不能用来传递敏感信息
- get参数通过url传递，post放在request body中

## Http和Https

http默认端口号80，https默认端口号443

http明文传输，对外暴露，https使用TLS/SSL加密传输

## HTTP工作原理

客户端与服务器建立连接，客户端发送一个请求给服务端，服务端返回状态行，客户端将内容渲染到浏览器上

## HTTPS工作原理

客户端访问Web服务器，要求与Web服务器建立SSL连接

Web服务器收到客户端请求后，会将网站的证书信息含公钥传送给客户端

客户端验证证书是否有效，证书没问题就会生成一个随机值，然后用公钥对随机值加密发送给服务端

服务端用私钥解密得到客户端随机值，非对称加密结束，传输网页内容用随机值进行对称加密

客户端收到加密内容，用随机值解密后将内存渲染到浏览器上

[https加密](https://blog.csdn.net/WoTrusCA/article/details/100105031)

## DNS

1. 主机先向本地域名服务器进行递归查询
2. 本地域名服务器采用迭代查询，向一个根域名服务器进行查询
3. 根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器的IP地址
4. 本地域名服务器向顶级域名服务器进行查询
5. 顶级域名服务器告诉本地域名服务器，下一步查询权限服务器的IP地址
6. 本地域名服务器向权限服务器进行查询
7. 权限服务器告诉本地域名服务器所查询的主机的IP地址
8. 本地域名服务器最后把查询结果告诉主机

（1）递归查询：本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机
（2）迭代查询：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。