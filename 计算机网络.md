## 三次握手

![在这里插入图片描述](https://img-blog.csdnimg.cn/eccf435f384041a69698b5ca18c30028.PNG?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAanVuMjAxNjQyNQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

![这里写图片描述](https://img-blog.csdn.net/20180809183055554?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bjIwMTY0MjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

第一次握手

客户端给服务器发送一个SYN段数据包，初始序列号seq = x，客户端状态转变为SYN_SEND

第二次握手

服务器返回客户端SYN +ACK段数据包，初始序列号seq = y，ack = x + 1，服务端状态转变为SYN_RCVD

第三次握手

客户端给服务器响应一个ACK段数据包，初始序列号ack = y + 1，客户端状态转变为ESTABLISHED；服务端收到包后状态转变为ESTABLISHED

## 四次握手

![img](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

第一次握手

客户端向服务端发送FIN段的数据包，初始序列号seq = x，客户端状态转变为FIN-WAIT-1

第二次握手

服务端向客户端发送ACK段的数据包，初始序列号seq = a，ack = x + 1，服务端状态转变为CLOSE-WAIT；客户端收到数据包状态转变为FIN-WAIT-2

第三次握手

服务端向客户端发送FIN + ACK段的数据包，初始序列号seq = y，ack = x + 1，服务端状态转变为LAST-ACK

第四次握手

客户端向服务端发送ACK段的数据包，初始序列号seq = x + 1，ack = y + 1，客户端状态转变为TIME-WAIT，等待2MSL，状态再转变为CLOSED；服务端收到包后状态转变为CLOSED

## 其他问题

【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

答：所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

## TCP和UDP

TCP是面相字节流，传输数据前必须先建立连接，数据传送后释放连接，全双工通信，而UDP不建立连接，面相报文

TCP提供可靠交付，按序到达，而UDP尽最大努力交付

TCP是单播形式，UDP是广播形式

## 慢开始

![img](https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987429/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg)

### 慢开始

把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。每经过一个**传输轮次**，拥塞窗口 cwnd 就翻倍。 设置一个慢开始门限ssthresh状态变量。

 当 cwnd < ssthresh 时，使用慢开始[算法]()。

 当 cwnd > ssthresh 时，使用拥塞避免[算法]()。

 当 cwnd = ssthresh 时，既可使用慢开始[算法]()，也可使用拥塞控制避免[算法]()。

### 拥塞避免

每经过一个**往返时间RTT**就把发送方的拥塞窗口cwnd加1。无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就门限ssthresh设置为发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始[算法]()。

### 快重传

有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。

快重传[算法]()可以避免这个问题。快重传[算法]()首先要求接收方每收到一个失序的报文段后就立即发出重复确认，使发送方及早知道有报文段没有到达对方。

发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。

### 快恢复

当发送方连续收到三个重复确认，就会把慢开始门限ssthresh减半，接着把cwnd值设置为ssthresh一样的值，然后开始执行拥塞避免[算法]()，使拥塞窗口缓慢地线性增大。

## get和post

- get在浏览器回退时是无害的，而post会再次提交请求
- get请求会被浏览器存进历史记录，而post不会
- get请求只能进行url编码，而post支持多种编码方式
- get请求在url有长度限制(输入框大小)，而post没有
- 对参数的数据类型，get只接受ASCLL字符，而post没有限制
- get参数存放url中，post放在请求体中，gei比post不安全

## Http和Https

http默认端口号80，https默认端口号443

http明文传输，对外暴露，https使用TLS/SSL加密传输

## HTTP工作原理

客户端与服务器建立连接，客户端发送一个请求给服务端，服务端返回状态行，客户端将内容渲染到浏览器上

## HTTPS工作原理

浏览器将自己支持的加密规则发送给服务端

服务端从中选出一组加密算法，并将自己身份信息以证书形式(网站地址、公钥、证书颁发即构)发回给浏览器

客户端验证证书是否有效，证书没问题就会生成一个随机值，公钥对随机值加密发送给服务端

服务端用私钥解密得到浏览器随机值，非对称加密结束

传输网页内容用随机值进行对称加密

客户端收到加密内容，用随机值解密后将内存渲染到浏览器上

[https加密](https://blog.csdn.net/WoTrusCA/article/details/100105031)

## DNS

1. 浏览器缓存
2. OS缓存
3. hosts文件
4. 向本地域名服务器进行递归查询
5. 本地域名服务器迭代查询，根域名服务器、顶级域名服务器、权限服务器
10. 权限服务器告诉本地域名服务器所查询的主机的IP地址
11. 本地域名服务器最后把查询结果告诉主机

（1）递归查询：本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机
（2）迭代查询：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。

## 进程和线程

进程是管理和分配资源的基本单位，是动态概念，竞争计算机系统资源的基本的单位

线程是进程的一个执行单元，是进程调度的实体

线程间共享本进程地址空间和资源，进程间相互独立

线程崩溃本进程跟着崩溃

创建线程比创建进程开销小，线程切换比进程切换开销小

## Unicode和UTF-8

Unicode是字符集

UTF-8是编码规则

# 加密与非对称加密

1、对称加密：加密与解密使用同一秘钥。

　　特点： 1、加密强度不高，但效率高; 2、密钥分发困难。

　　(大量明文为了保证加密效率一般使用对称加密)

　　常见对称密钥加密(共享密钥加密)算法：AES、DES(56位)、 3DES(112位)。

2、非对称加密：公钥加密，相应的私钥解密。

　　特点：加密速度慢，但强度高。

　　常见非对称密钥加密算法： RSA、DSA

