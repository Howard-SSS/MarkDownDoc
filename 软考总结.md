

[toc]



<table>
  <tr>
    <td>OSI的体系结构</td>
    <td>TCP/IP的体系结构</td>
    <td>五层协议的体系结构</td>
  </tr>
  <tr>
    <td>应用层</td>
    <td rowspan="3">应用层(各种应用层协议如TELNET,FTP,SMTP等</td>
    <td rowspan="3">应用层</td>
  </tr>
  <tr>
    <td>表示层</td>
  </tr>
  <tr>
  	<td>会话层</td>
  </tr>
  <tr>
  	<td>运输层</td>
    <td>运输层(TCP或UDP)</td>
    <td>运输层</td>
  </tr>
  <tr>
    <td>网络层</td>
    <td>网际层IP</td>
    <td>网络层</td>
  </tr>
  <tr>
  	<td>数据链路层</td>
    <td rowspan="2">网络借口层</td>
    <td>数据链路层</td>
  </tr>
  <tr>
  	<td>物理层</td>
    <td>物理层</td>
  </tr>
</table>



## 物理层

![image-20210822211553716](/Users/howard/Library/Application Support/typora-user-images/image-20210822211553716.png)

![image-20210822211949352](/Users/howard/Library/Application Support/typora-user-images/image-20210822211949352.png)![image-20210822211949396](/Users/howard/Library/Application Support/typora-user-images/image-20210822211949396.png)

![image-20210822212320767](/Users/howard/Library/Application Support/typora-user-images/image-20210822212320767.png)



## 数据链路层

封装成帧

![image-20210829162536206](/Users/howard/Library/Application Support/typora-user-images/image-20210829162536206.png)

透明传输

![image-20210829162619552](/Users/howard/Library/Application Support/typora-user-images/image-20210829162619552.png)

差错检测

要发送k位数据M,双方约定n+1位的除数P,给M*2^n^得M‘,M'除以P得n位余数R,将M与R拼接发送出去

![image-20210829165604703](/Users/howard/Library/Application Support/typora-user-images/image-20210829165604703.png)

接收端将收到的数据以帧为单位进行CRC检验(除以P),若余数R为0,则传输工程中无差错



# 1.数据的表示

内存容量 = 末地址-首地址+1

1GB=

1MB\*1024=

1KB\*1024\*1024=

1B\*1024\*1024\*1024=

8\*1024\*1024\*1024

4K\*8=4KB

## 1.1进制转换

### 十进制转R进制、R进制转十进制

十进制整数转换为 N 进制整数采用 “除 N 取余，逆序排列” 法。十进制小数转换成 N 进制小数采用 “乘 N 取整，顺序排列” 法。

![07_十进制转八进制](https://haicoder.net/uploads/pic/server/c/program-knowledge/07_%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%85%AB%E8%BF%9B%E5%88%B6.png)

![09_十进制转八进制](https://haicoder.net/uploads/pic/server/c/program-knowledge/09_%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%85%AB%E8%BF%9B%E5%88%B6.png)

### 二进制转八、转十六进制(分组快速转换)

| 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| A    | B    | C    | D    | E    | F    |

二进制转八进制

![11_二进制整数转八进制](https://haicoder.net/uploads/pic/server/c/program-knowledge/11_%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0%E8%BD%AC%E5%85%AB%E8%BF%9B%E5%88%B6.png)

二进制转十六进制

![13_二进制整数转十六进制](https://haicoder.net/uploads/pic/server/c/program-knowledge/13_%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0%E8%BD%AC%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6.png)

| 10.101.144.99                                         | 38FFH |
| ----------------------------------------------------- | ----- |
| 00001010.<br />01100101.<br />10010000.<br />01100011 |       |

## 1.2原码/补码/反码/移码

原码：正数是其二进制本身，负数是符号位为1，数值部分绝对值的二进制

反码：正数是其二进制本身，负数是符号位为1，其他位取反

补码：正数是其二进制本身，负数是符号位为1，其他位取反，末位加1

移码：将符号位取反的补码

| 编码 | 108（10）    | -108（10）   | 0.1011（2） | -0.1011（2） |
| ---- | ------------ | ------------ | ----------- | ------------ |
| 原码 | **0**1101100 | **1**1101100 | **0**.1011  | **1**.1011   |
| 反码 | **0**1101100 | **1**0010011 | **0**.1011  | **1**.0100   |
| 补码 | **0**1101100 | **1**0010100 | **0**.1011  | **1**.0101   |
| 移码 | **1**1101100 | **0**0010100 | **1**.1011  | **0**.0101   |

![5e52a22d43ee9](http://www.kokojia.com/Public/images/upload/article/2020-02/5e52a22d43ee9.png)

-0补码为[0000 0000]~补~

使用以前-0的补码[1000 0000]~补~表示-128,-128没有原码和反码

## 1.3浮点数的表示

N=M*R^e^

| M    | R                |      |
| ---- | ---------------- | ---- |
| 尾数 | 基数（2、8、16） | 阶码 |

![jingdu](https://img-blog.csdn.net/20161222092607865?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1emZhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

单精度浮点数真值

$x=（-1）^S*(1.M)*R^e$

$e=E-127$

双精度浮点数真值

$x=(-1)^S*(1.M)*R^e$

$e=E-1023$

0.5单精度存储

0.5=(0.1)~2~=(1.0*2^-1^)2

S=0,M=0,e=-1 -> E=126

0.5=[0 011,1111,10 00,0000,0000,0000,0000,0000]~2~

最大正数:(1-2\^(-M+1))*2\^(2\^(R-1)-1)

最小负数:-1*2\^(2\^(R-1)-1)

R=阶符+阶码值

M=数符+尾数

## 1.4浮点数运算

a=0.3,b=1.6,计算a+b

a=0.3=(0011 1110 1001 1001 1001 1001 1001 1010)~2~

b=1.6=(0011 1111 1100 1100 1100 1100 1100 1101)~2~

对阶

E~a~<E~b~ E~b~-E~a~=2

M~a~=M~a~\*2^-2^=1.001 1001 1001 1001 1001 1010\*2^-2^

  0.01001100110011001100110**10**(舍弃)

+1.10011001100110011001101

<hr>

  1.11100110011001100110011‬

a+b=(0 01111111 11100110011001100110100)2=(0011 1111 1111 0011 0011 0011 0011 0100)2=(3FF33334)16

# 2.运算器与控制器

​		1、运算器：

　　①算术逻辑单元ALU：数据的算术运算和逻辑运算

　　②累加寄存器AC：通用寄存器，为ALU提供一个工作区，用在暂存数据

　　③数据缓冲寄存器DR：写内存时，暂存指令或数据

　　④状态条件寄存器PSW：存状态标志与控制标志(争议：也有将其归为控制器的)

　　2、控制器：

　　①程序计数器PC：存储下一条要执行指令的地址

　　②指令寄存器IR：存储即将执行的指令

　　③指令译码器ID：对指令中的操作码字段进行分析解释

　　④时序部件：提供时序控制信号

CPU运算单元、控制单元和寄存器之间通过内部总线连接起来

# 映射

地址映射的冲突:全相联映射<组相联映射<直接映射

**全相联映射**

主存的任意一块可以映象到Cache中的任意一块

![img](https://img-blog.csdn.net/20171116105644715)

**直接相联映射**

主存中一块只能映射到Cache的一个特定的块中

![327.gif](https://static.oschina.net/uploads/img/201803/07163540_dO4M.gif)

**组相连映射**

各区中的某一块只能存入缓存的同组号的空间内

![img](https://img-blog.csdn.net/20180425165250180)

# 3.Flyyn分类法

Single 单
Multiple 多

**费林分类法**（Flynn's Taxonomy），是一种高效能计算机的分类方式。1972年费林（Michael J. Flynn）根据资讯流（information stream）可分成**指令（Instruction）和资料（Data）**两种。据此又可分成四种计算机类型：

![img](http://www.kokojia.com/Public/images/upload/article/2020-02/5e52a46ba332c.png)

指令看控制器,资料看处理器

# 4.CISC与RISC

RISC和CISC是CPU指令系统架构区分的

复杂指令集

指令数量多,指令频率差别大,支持多种方式寻址,使用微码(复杂指令转换成微程序,微程序包含若干微指令(微码))、能够直接对主存单元中的数据进行处理

精简指令集

指令数量少,操作寄存器,单周期,增加了通用寄存器,硬布线逻辑控制为主,采用流水线,更好支持高级语言

# 5.流水线技术

流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度

https://segmentfault.com/a/1190000039201150

以下均为度为1(一下只能执行一条指令)

流水线执行时间(理论公式)

(t1+t2+..+tk)+(n-1)*∆t

t1...tk一条指令每个周期时间,n指令条数,∆t流水线周期(最长的周期时间)

流水线执行时间(实践公式)

k*∆t +(n-1)*∆t

流水线吞吐量

$TP=\frac{指令条数}{流水线执行时间}=\frac{n}{k*∆t +(n-1)*∆t}$

流水线最大吞吐率

$TP_{max}=\displaystyle \lim_{n \to \infty}\frac{n}{(k+n-1)∆t}=\frac{1}{∆t}$

流水线加速比

$\frac{顺序执行时间}{流水线执行时间}=\frac{n*k*∆t}{k*∆t +(n-1)*∆t}=\frac{n*k}{k+n-1}$

# 6.存储系统

多级存储体系的分布

![img](https://bkimg.cdn.bcebos.com/pic/c9fcc3cec3fdfc0329f3d882d73f8794a4c22604?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto)

局部性分为：时间局部性和空间局部性。如果一个内存位置被重复的引用，那就是有了时间局部性，如果一个内存位置被引用了，很快这个位置的附近位置也被引用了，这就有了空间局部性。

# 总线系统

**数据总线**

CPU与内存或其他器件之间的数据传送的通道

如字长为32,数据总线32位

**地址总线**

CPU是通过地址总线来指定存储单元的

地址总线决定了cpu所能访问的最大内存空间的大小

如内存容量4GB = 4\*1024\*1024\*1024 = 2^32^,地址总线32位

**控制总线**

CPU通过控制总线对外部器件进行控制

**总线结构**

https://www.caishi.cn/questionCenter/questionDetails?chapterId=1604381987074-1f496872-a649-4d1b-a56f-f888ba22ea97&testPageRuleId=1577775787232-b468c69f-87ae-4297-aa34-e7274c9128c9&chooseType=chapter&categoryId=20191218160048-1b0257b4-3a81-4e25-9b7d-4b159a859d36

# 可靠性

$R_{t}为t时刻正常运行的概率$

| 系统类型   | 可靠性                                                       |
| ---------- | ------------------------------------------------------------ |
| 串联系统   | $R=R_{1}*R_{2}*R_{3}*...*R_{n}$                              |
| 并联系统   | $R=1-(1-R_{1})*(1-R_{2})*...*(1-R_{n})$                      |
| 模冗余系统 | ![270845180529853](https://images0.cnblogs.com/blog2015/652582/201504/270845180529853.png) |

# 校验码

**奇偶校验**

奇校验: 原始码流 + 校验位 总共有奇数个1

偶校验: 原始码流 + 校验位 总共有偶数个1

缺点: 只能判断奇数错误, 不能纠错

**循环校验码CRC**

![v2-fd19ba1c93f543d650f12efa8c3a1b14_1440w](https://pic1.zhimg.com/80/v2-fd19ba1c93f543d650f12efa8c3a1b14_1440w.jpg)

可查错,不可纠错

**海明校验码**

2^r^-1>=k+r

k个数据位,r个检验位

**注意： 信息位的位置分配是从高位到低位依次存放**
**注意： 海明校验码是放在2的幂次位上的**

https://www.jianshu.com/p/1e43286d9b1a

https://blog.csdn.net/flyyufenfei/article/details/72235748

# 冗余附加技术

冗余技术又称储备技术,它是利用系统的关联模型来提高系统可靠性的一种手段

冗余附加包括:独立设计的**相同功能**的冗余备份程序的存储及调用;实现**纠错检测及恢复**的程序;为实现**容错软件所**需的固化程序

# 死锁及银行家算法

**死锁条件**

- 互斥条件: 一个资源每次只能被一个进程使用
- 请求和保持: 一个进程因请求资源而阻塞时,对已获得的资源保持不放
- 不可抢占: 进程已获得的资源,在未使用完之前,不能强行剥夺
- 循环等待: 若干进程之间形成一种头尾相接的循环等待资源关系

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之
一不满足，就不会发生死锁

**条件死锁的预防**

- 破坏“请求与保持”条件
  方法一：静态分配，每个进程在开始执行时就申请他所需要的全部资源。
  方法二：动态分配，每个进程在申请所需要的资源时他本身不占用系统资源。
- 破坏“不可剥夺”条件
  一个进程不可获得其所需要的全部资源便处于等待状态，等待期间他占用的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。
- 破坏“循环等待”条件
  采用资源有序分配的基本思想。将系统中的资源顺序进行编号，将紧缺的、稀少的资源采用较大的编号，申请资源时必须按照编号的顺序执行，一个进程只有较小编号的进程才能申请较大编号的进程。

**银行家算法**

![img111111](https://img2018.cnblogs.com/i-beta/1358881/201911/1358881-20191125165114981-1954446360.png)

![1358881-20191125171020518-1171969079](https://img2018.cnblogs.com/i-beta/1358881/201911/1358881-20191125171020518-1171969079.png)

**进程资源图**

![1619675849496-87765d90-6cb3-4165-ad59-2d363f0d4e04](https://oss-image.caishi.cn//test/tk/view/upload/ueditor/20210429/1619675849496-87765d90-6cb3-4165-ad59-2d363f0d4e04.png)

资源指向进程是分配资源,进程指向资源是申请

# PCB组织方式

**线性表方式**

不管进程状态,将所有PCB连续地存放在内存的系统区

**索引表方式**

按照进程状态分别建立就绪索引表、阻塞索引表

**链接表方式**

按照进程状态将进程的PCB组成队列,就绪队列、阻塞队列、运行队列

# 段页式存储

# 页面置换算法

https://houbb.github.io/2020/10/04/os-10-page-exchange

**最佳置换算法OPT**

缺页时判断未来哪个页最晚被使用,就用新页替换该页!![image-20211024143329376](/Users/howard/Library/Application Support/typora-user-images/image-20211024143329376.png)

中断9次,页面置换6次

**先进先出FIFO页面置换算法**

![211558_791ef09a_508704](https://images.gitee.com/uploads/images/2020/1005/211558_791ef09a_508704.png)

中断15次,页面置换12次

**最近最久未使用LRU置换算法**

![211813_2a3d806b_508704](https://images.gitee.com/uploads/images/2020/1005/211813_2a3d806b_508704.png)

**clock置换算法**

u为use访问位,m位modify修改位

第一轮将(u=0,m=0)替换

失败将(u=0,m=1)替换

失败将u置0,重新

# 绝对路径和相对路径

# 索引文件(难)

# 周期

**指令周期**

取出并执行一条指令的时间

**总线周期**

也就是一个访存存储器I/O端口操作所用的时间

**时钟周期(震荡周期)**

处理操作的最基本单位

**机器周期**



在一个指令周期由若干个总线周期组成,而一个总线周期时间又包含若干个时钟周期

指令周期>机器周期>时钟周期

# 寻址方式

**立即寻址**

指令的地址字段指出的不是操作数的地址，而是操作数本身(零次访问内存)

**直接寻址**

在指令格式的地址的字段中直接指出操作数在内存的地址(一次访问内存)

**间接寻址**

指令地址字段中的形式地址不是操作数的真正地址(二次访问内存)

**寄存器寻址**

指令中给出的操作数地址不是内存的地址单元号，而是通用寄存器的编号(一次访问寄存次)

**寄存器间接寻址**

指令格式中的寄存器内容不是操作数，而是操作数的地址(一次访问寄存次,一次访问内存)

**相对寻址**

把程序计数器PC的内容加上指令格式中的形式地址D而形成操作数的有效地址

**基址寻址**

将CPU中的**基址寄存器**的内容，加上**变址寄存器**的内容而形成操作数的有效地址

**变址寻址**

某个**变址寄存器**的内容与偏移量D相加来形成操作数有效地址

# 逻辑地址转物理地址

![1619676060113-34311191-827a-4bf3-85ec-9ba62d4607e7](https://oss-image.caishi.cn//test/tk/view/upload/ueditor/20210429/1619676060113-34311191-827a-4bf3-85ec-9ba62d4607e7.png)

- 页面大小4k=2^12^,表示12位页内地址
- 2D16H=0010,110100010110B,后12位是页内地址,前4位是页号2
- 转换物理块号4,块号和页内地址组合成物理地址
- 0100,110100010110B=4D16H

# 缓冲区

https://blog.csdn.net/weixin_43899069/article/details/109529164

题目：假设磁盘块与缓冲区大小相同，每个盘块读入缓冲区的时间为15μs，由缓冲区送至用户区的时间是5μs，系统对每个磁盘块数据的处理时间为2μs。若用户需要将大小为10个磁盘块的Docl文件逐块从磁盘读入缓冲区，并送至用户区进行处理，那么采用单缓冲区需要花费的时间为（ ）μs；采用双缓冲区需要花费的时间为（ ）μs。

- 在块设备输入数据的过程中，首先把磁盘数据送到缓冲区，花费的时间为Ts
- 然后把操作系统缓冲区的数据送到用户区，花费的时间为Tm
- 最后用户进程对这批数据进行计算，花费的时间为Tc

**单缓冲区**

因此Ts 与Tm无法并行，如图

![img](https://img-blog.csdnimg.cn/20201106121005560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5OTA2OQ==,size_16,color_FFFFFF,t_70#pic_center)

当T~s~>T~C~

总时间:T~总~=n*(T~s~+T~m~)+T~c~

当T~s~<T~C~

总时间:T~总~=n*(T~c~+T~m~)+T~s~

**双缓冲区**

Ts过程与Tm可以并行，Tm过程与Tc过程不能并行，如图

![img](https://img-blog.csdnimg.cn/20201106121429313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5OTA2OQ==,size_16,color_FFFFFF,t_70#pic_center)

当T~s~>T~C~

总时间:T~总~=n*T~s~+T~m~+T~c~

当T~s~<T~C~

总时间:T~总~=n*(T~c~+T~m~)+T~s~

# 位示图

https://www.cxyzjd.com/article/xc917563264/113791365

![img](https://img-blog.csdnimg.cn/2021021118255615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hjOTE3NTYzMjY0,size_16,color_FFFFFF,t_70)

1、对于位示图，每一个bit位可以表示一个磁盘的占用情况，“0”表示空闲，“1”表示占用。

　　2、对于字的长度与具体机器字长有关，有题目指定，假设机器字长16位，则每个字可以表示16个磁盘块的占用情况;

　　3、指定序号为n或第n+1个磁盘，占用情况需要用m=(n+1)/16(向上取整)个字表示，字的序号为m-1。注意其中磁盘序号、字的序号、对应位号都是从0开始，计算过程中会有加1或减1处理。

# 磁盘管理

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191011153619423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1NzE0Mw==,size_16,color_FFFFFF,t_70)

**存取时间** = 寻道时间(磁头移动到磁道所需的时间) + 等待时间(等待读写扇区转到磁头下方所用的时间) + 数据传输时间

**磁盘调度算法**

https://www.cxyzjd.com/article/weixin_43957143/102502402

先来先服务

最短寻道时间优先

扫描算法(电梯调度算法)广泛用于大中小型机和网络中的磁盘调度(双向)

循环扫描算法(单向)

**存储优化**

# 设备管理

**无条件传送**

I/O端口总是准备好接受主机的输出数据,或是总是准备好向主机输入数据

**程序查询方式**

CPU不停循环测试I/O设备的状态端口,当设备准备好,CPU与I/O设备进行数据存取操作(串行)(CPU一直处于询问、等待的过程，占用CPU时间最长,CPU利用率最低)

**中断方式**

I/O完成后向CPU发送中断请求信号,CPU处理完后回到之前的工作(并行)(大大提高CPU利用率)

**DMA(直接内存存取)**

允许主存储器和I/O设备之间通过DMA控制器直接进行批量数据交换,除了数据传输开始和结束时,整个过程无须CPU的干预(CPU只做初始化，不参与具体数据传输过程)

**通道方式**

在一定硬件基础上利用软件手段实现对I/O的控制和传送,更多地免去了CPU的接入

**I/O处理机**

专门负责输入、输出的处理机,可以独立的存储器、运算部件和指令控制部件

**专用硬件方式**

# 虚设备和SPOOLING技术

为了缓和CPU的高速性与I/O设备低速性间的矛盾而引入了脱机输入、脱机输出技术。该技术是利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上；或者相反。事实上，当系统中引入了多道程序技术后，完全可以利用其中的一道程序，来模拟脱机输入时的外围控制机的功能，把低速I/O设备上的数据传送到高速磁盘上；再用另一道程序来模拟脱机输出时外围控制机的功能，把数据从磁盘上传送到低速输出设备上。这样，便可在主机的直接控制下，实现脱机输入、输出功能。此时的外围操作与CPU对数据的处理同时进行，我们把这种在联机情况下实现的同时外围操作称为SPOOLing，或称为假脱机操作。![5e53cb2963488](http://www.kokojia.com/Public/images/upload/article/2020-02/5e53cb2963488.png)

# 数据库设计

- 需求分析
- 逻辑设计

E-R图转换成关系模式

- 概念设计

用户角度、E-R图

- 物理设计

物理存储方法、索引

# 数据库模式

1、三级模式：外模式(子模式、用户模式)对应视图，模式(逻辑模式、概念模式)对应数据库表，内模式对应物理文件。

2、两层映像：外模式-模式映像，模式-内模式映像;两层映像可以保证数据库中的数据具有较高的**逻辑独立性**和**物理独立性**。

3、逻辑独立性：即逻辑结构发生改变时，用户程序对外模式的调用可以不做修改;物理独立性：即数据库的内模式发生改变时，数据的逻辑结构不变。

# ER模型

1、E-R图各元素的定义：

　　(1)实体：用矩形表示，是现实世界中可以区别于其他对象的“事件”或“物体”，如学生、老师、课程等。

　　(2)弱实体：用双边矩形表示，与依赖的实体以带圆形的线连接，与实体有很强的依赖关系，单独存在没有意义，也体现为某个实体的特殊化对象。如依赖学生的家属实体，依赖邮件的附件实体，员工的特殊化对象弱实体经理。

　　(3)联系：用菱形表示，反映实体与实体之间的联系，有1对1、1对多、多对多3种类型，可以有三元联系存在。如学生与课程可以存在多对多的联系。

　　(4)属性：用椭圆表示，是实体某方面的特性，体现为表中的属性列名。如学生的学号、年龄等。

　　E-R图图示如下：

　　

![img](http://www.kokojia.com/Public/images/upload/article/2020-02/5e53cce7ca92e.png)

 

　　2、E-R图转关系模式：

　　(1)一个实体型转换为一个关系模式。

　　(2) 联系转关系模式：

　　1：1联系：可将联系合并至任意一端的实体关系模式中。

　　1：n联系：可将联系合并至n端实体关系模式中。

　　m：n联系：联系必须单独转成关系模式。

# 关系代数

1、并(结果为二者元组之和去除重复行)

　　2、交(结果为二者重复行)

　　3、差(前者去除二者重复行)

　　类似于集合运算，计算如下图所示：

　　

![img](http://www.kokojia.com/Public/images/upload/article/2020-02/5e53ce0adb3c8.png)

 

　　4、笛卡尔积：结果列数为二者属性列数之和，行数为二者元素数乘积。

　　5、投影：对属性列的选择列出。

　　6、选择：对元组行的选择列出。

　　属性名可以依次标序号，直接以数字形式出现在表达式中。计算如下图所示：

　　

![img](http://www.kokojia.com/Public/images/upload/article/2020-02/5e53ce1400592.png)

 

　　7、自然连接：结果列数为二者属性列数之和减去重复列，行数为二者同名属性列其值相同的结果元组。笛卡尔积、选择、投影的组合表示可以与自然连接等价。

　　普通连接的条件会写出，没有写出则表示为自然连接。计算如图所示：

　　

![img](http://www.kokojia.com/Public/images/upload/article/2020-02/5e53ce1c8d06c.png)

**左(外)连接**

左表的记录将会全部表示出来,右表只会显示符合搜索条件的记录

**全(外)连接**

左右都显示

# TCP/IP协议族

![5e53cf690067a](http://www.kokojia.com/Public/images/upload/article/2020-02/5e53cf690067a.png)

FTP服务器控制端口21,数据口20

**SNMP协议**中,团体名相当于一个组,在进行管理时,是以团体名为单位进行管理的,基作用域也在相同团体名之内



# IP地址与子网划分

# 网络规划与设计

# 3G/4G标准

![5e53d1b70a673](http://www.kokojia.com/Public/images/upload/article/2020-02/5e53d1b70a673.png)

# 规范化理论

https://blog.csdn.net/Dream_angel_Z/article/details/45175621

**1NF**

列不能再分,如【联系人】姓名，性别，电话),电话可分为家庭电话和公司电话

**2NF**

1NF基础上,一个表必须有一个主键,没有包含在主键中的列必须完全依赖于主键,而不能只依赖于主键一部分

(若依赖主键一部分,可列独立于新的表,防止产生冗余)

**3NF**

2NF基础上,非主属性不依赖于其他非主属性(不能因为传递以来而依赖主键)

**BCNF**

3NF基础上,消除主属性对候选码的部分依赖

# SQL语言

**数据耦合**

一个模块访问另一个模块时,彼此之间是通过数据参数来交换输入、输出信息的

**标记耦合**

一组模块通过参数表传递记录信息

**控制耦合**

一个模块通过传送开关、标志、名字等控制信息,明显地控制选择另一个模块的功能

**内容耦合**

数据库系统中,构成数据模型的三要素数据结构、数据操作、完整性约束

# 图

**数据流图DFD**

![img](http://p1-tt.bytecdn.cn/large/pgc-image/1bc10ee98372468081d7ac3e21522c63)

![img](http://p6-tt.bytecdn.cn/large/pgc-image/662e031286ea4a57ba2cd986041966ef)

**实体关系图ERD**

用于结构化分析过程中的数据建模

# 并发控制

1、事务特性(ACID)：

　　(1)原子性：事务是原子的，要么都做，要么都不做。

　　(2)一致性：事务执行的结果必须保证数据库从一个一致性状态变到另一个一致性的状态。因此，当数据库只包含成功事务提交的结果时，称数据库处于一致性状态。

　　(3)隔离性：事务相互隔离，当多个事务并发执行时，任一事务的更新操作直到其成功提交的整个过程，对其他事务都是不可见的。

　　(4)持续性：一旦事务成功提交，即使数据库崩溃，其对数据库的更新操作也将永久有效。

2、并发产生的问题

![5e53f19775f80](http://www.kokojia.com/Public/images/upload/article/2020-02/5e53f19775f80.png)

3、封锁协议：

　　(1)共享锁(S锁)：若事务T对数据对象A添加了S锁，则只允许T读取A，但不能修改A。并且其他事务只能对A加S锁，不能加X锁。

　　(2)排他锁(X锁)：若事务T对数据对象A添加了X锁，则只允许T读取和修改A，其他事务不能再对A加任何锁。

# 完整性约束

1、实体完整性：规定其主属性不能去空值。

2、参照完整性(也称为引用完整性)：规定其外键为参照表的主键值或为空值。

3、用户自定义完整性：指用户针对某一具体的关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的予以要求，由应用的环境决定，如年龄定义为0~150正整数。

4、触发器：一种复杂的完整性约束。

# 互连参考模型OSI

![5e53effc73251](http://www.kokojia.com/Public/images/upload/article/2020-02/5e53effc73251.png)

# HTML语言

![5e53ee87976c5](http://www.kokojia.com/Public/images/upload/article/2020-02/5e53ee87976c5.png)

# 对称加密与非对称加密

1、对称加密(又称为私人秘钥加密/共享秘钥加密)：加密与解密使用同一秘钥。

　　特点： 1、加密强度不高，但效率高; 2、密钥分发困难。

　　(大量明文为了保证加密效率一般使用对称加密)

　　常见对称密钥加密(共享密钥加密)算法：DES(56位)、 3DES(三重DES)(112位)、 RC-5、IDEA、AES算法。

　　2、非对称加密(又称为公开密钥加密)：密钥必须成对使用(公钥加密，相应的私钥解密)。

　　特点：加密速度慢，但强度高。

　　常见非对称密钥加密算法： RSA、ECC

# 信息摘要与数字签名

1、数字签名的过程如下图所示(发送者使用自己的私钥对摘要签名，接收者利用发送者的公钥对接收到的摘要进行验证)：

　　

![img](http://www.kokojia.com/Public/images/upload/article/2020-02/5e53ed0f10de7.png)

 

　　2、常见的摘要算法：MD5(128位)，SHA(160位)。

非对称加密

公钥加密,私钥解密

数字证书

私钥签名,公钥验收

https://segmentfault.com/a/1190000024523772

# 数字证书

1、数字证书的内容包括：CA签名、用户信息(用户名称)、用户公钥等。

　　2、CA签名验证数字证书的可靠性。

　　3、用户公钥：客户端利用证书中的公钥加密，服务器利用自己的私钥解密。

# 网络安全协议

1、安全协议分层如图所示：

　　

![img](http://www.kokojia.com/Public/images/upload/article/2020-05/5eca3b0655c0a.png)

 

　　2、HTTPS协议是HTTP协议与SSL协议的结合，默认端口号443。

　　3、PGP协议是邮件安全协议。

　　4、SET协议是电子商务安全协议，涉及电子交易安全。

# DMZ

防止建立防火墙后外部网络不能连接内部网络服务器而设立的一个非安全系统与安全系统之间的缓冲区,可以放置公开的服务器设施,Web服务器、FTP服务器

# 防火墙技术与网络攻击

1、网络攻击分类如下图所示：

　　

![img](http://www.kokojia.com/Public/images/upload/article/2020-05/5eca3b43cbe84.png)

 

　　2、常见的攻击行为

　　(1)拒绝服务：攻击者利用众多傀儡主机向服务器发送服务请求，导致服务器资源被耗尽，无法提供正常的服务，向其他访问者发送拒绝服务应答。

　　(2)重放攻击：攻击者抓取向服务器发送的有效数据包，并利用此数据包不断地向服务器发送，导致服务器一直应答此数据包，从而崩溃。

　　(3)业务流分析：通过长期监听被攻击者的数据流，从而分析出相关业务流，可以依此了解被攻击者的一些倾向，常见的广告推送就是建立在业务流分析基础上的。

　　3、常见的防御手段(可以结合使用)

　　(1)防火墙技术：主要了解它的机制是防外不防内，对于DMZ非军事区主要放置应用服务器(如邮件服务器，WEB服务器)。

　　(2)漏洞扫描：入侵者可以利用系统漏洞侵入系统，系统管理员可以通过漏洞扫描技术，及时了解系统存在的安全问题，并采取相应措施来提高系统的安全性。

　　(3)入侵检测IDS：基于数据源的分类-审计功能、记录安全性日志。基于检测方法-异常行为检测。

# 计算机病毒与木马

1、常见的病毒、木马命名：

　　系统病毒(前缀：Win32、PE、W32，如：KCOM——Win32.KCOM)

　　蠕虫病毒(如：恶鹰——Worm.BBeagle)

　　木马病毒、黑客病毒(如：QQ消息尾巴木马——Trojan.QQ3344)

　　脚本病毒(如：红色代码——Script.Redlof)(蠕虫、计算机病毒、木马为一体)

　　宏病毒(如：美丽莎——Macro.Melissa)

　　后门病毒(如：灰鸽子——Backdoor.Win32.Huigezi)

　　病毒种植程序病毒(冰河播种者——Dropper.BingHe2.2C)

　　破坏性程序病毒(杀手命令——Harm.Command.Killer)

　　玩笑病毒(如：女鬼——Jioke.Grl ghost)

　　捆绑机病毒(如：捆绑QQ——Binder.QQPass.QQBin)

　　2、常见的病毒分类：

　　(1)文件型计算机病毒感染可执行文件(包括EXE和COM文件)。

　　(2)引导型计算机病毒影响软盘或硬盘的引导扇区。

　　(3)目录型计算机病毒能够修改硬盘上存储的所有文件的地址。

　　(4)宏病毒感染的对象是使用某些程序创建的文本文档、数据库、电子表格等文件。

　　3、病毒的特性：计算机病毒的特性包括**隐蔽性、传染性、潜伏性、触发性和破坏性**等

# 被动攻击

窃听、电磁或射频截获、业务流分析

# 主动攻击

截获和修改、重放、伪装、非法使用、拒绝服务、特洛伊木马、陷门

# 开发模型

1、瀑布模型：瀑布模型是将软件生存周期中的各个活动规定为依线性顺序连接的若干阶段的模型，包括需求分析、设计、编码、运行与维护。

　　瀑布模型的特点是容易理解，管理成本低，每个阶段都有对应的成果产物，各个阶段有明显的界限划分和顺序要求，**一旦发生错误，整个项目推倒重新开始**

　　适用于需求明确的项目，一般表述为需求明确、或二次开发，或者对于数据处理类型的项目。

　　2、V模型：强调测试贯穿项目始终，而不是集中在测试阶段。是一种测试的开发模型。

　　3、喷泉模型：典型的面向对象的模型。特点是迭代、无间隙。会将软件开发划分为多个阶段，但各个阶段无明显界限，并且可以迭代交叉。

　　4、原型模型：典型的原型开发方法模型。适用于需求不明确的场景，可以帮助用户明确需求。

　　5、增量模型：融合了瀑布模型的基本成分和原型实现的迭代特征，**可以有多个可用版本的发布**，核心功能往往最先完成，在此基础上，每轮迭代会有新的增量发布，核心功能可以得到充分测试。强调每一个增量均发布一个可操作的产品。

　　6、螺旋模型：典型特点是引入了风险分析。结合了瀑布模型和演化模型的优点，最主要的特点在于加入了风险分析。它是由制定计划、风险分析、实施工程、客户评估这一循环组成的，它最初从概念项目开始第一个螺旋。属于面向对象开发模型，强调风险引入。

　　7、统一过程(在软件设计师考试中UP、RUP都指统一过程)：典型特点是用例驱动、以架构为中心、迭代和增量。统一过程把一个项目分为四个不同的阶段：

　　构思阶段 ：包括用户沟通和计划活动两个方面，强调定义和细化用例，并将其作为主要模型。

　　细化阶段 ：包括用户沟通和建模活动，重点是创建分析和设计模型，强调类的定义和体系结构的表示。

　　构建阶段 ：将设计转化为实现，并进行集成和测试。

　　移交阶段 ：将产品发布给用户进行测试评价，并收集用户的意见，之后再次进行迭代修改产品使之完善

　　8、敏捷开发是一种以人为核心、迭代、循序渐进的开发方法，适用于**小团队和小项目**，具有小步快跑的思想。常见的敏捷开发方法有极限编程法、水晶法、并列争球法和自适应软件开发方法。

　　(1)极限编程是一种轻量级的开发方法，它提出了四大价值观：沟通、简单、反馈、勇气。五大原则：快速反馈、简单性假设、逐步修改、提倡更改、优质工作。十二个最佳实践：计划游戏、隐喻、小型发布、简单设计、测试先行、重构、结对编程、集体代码所有制、持续集成、每周工作40小时、现场客户和编码标准。

　　(2)水晶法强调经常交付，认为每一种不同的项目都需要一套不同的策略、约定和方法论。

　　(3)并列争球法的核心是迭代、增量交付，按照30天进行迭代开发交付可实际运行的软件。

　　(4)自适应软件开发的核心是三个非线性的，重迭的开发阶段：猜测、合作、学习。

# CMML

# 统一过程UP

起始、精化、构建、移交

# 概要设计文档

系统架构、模块划分、系统接口、数据设计

# 仓库风格

- 解决问题的多方法性
- 具有可更改性和可维护性
- 有可重用的知识源
- 支持容错性和健壮性

# 软件设计

1、软件设计的任务是解决怎么做的问题。软件设计包括体系结构设计、接口设计、数据设计和过程设计。

　　过程设计：系统结构部件转换成软件的过程描述。

　　结构设计：定义软件系统各主要部件之间的关系

遵循以下原则

- 模块大小要适中
- 模块的扇入和扇出要合理
- 深度和宽度要适当

　　接口设计(人机界面设计)：软件内部，软件和操作系统间以及软件和人之间如何通信。

主要任务:描述软件与外部环境之间的交互关系,软件内模块之间的调用关系

　　数据设计：将模型转换成数据结构的定义。好的数据设计将改善程序结构和模块划分，降低过程复杂性。

　　2、系统方案设计包括总体设计和各部分的详细设计两个方面。

　　系统总体设计：包括系统的总体架构方案设计、软件系统的总体架构设计、数据存储的总体设计、计算机和网络系统的方案设计等。

　　系统详细设计：包括代码设计、数据库设计、人/机界面设计、处理过程设计等。

　　3、软件设计的原则：高内聚、低耦合

　　(内聚性)

　　偶然聚合:模块完成的动作之间没有任何关系，或者仅仅是一种非常松散的关系。

　　逻辑聚合:模块内部的各个组成在逻辑上具有相似的处理动作，但功能用途上彼此无关。

　　时间聚合:模块内部的各个组成部分所包含的处理动作必须在同一时间内执行。

　　过程聚合:模块内部各个组成部分所要完成的动作虽然没有关系，但必须按特定的次序执行。

　　通信聚合:模块的各个组成部分所完成的动作都使用了同一个数据或产生同一输出数据。

　　顺序聚合:模块内部的各个部分，前一部分处理动作的最后输出是后一部分处理动作的输入。

功能聚合:模块内部各个部分全部属于一个整体，并执行同一功能，且各部分对实现该功能都比不可少

　　(耦合性)

　　非直接耦合:两个模块之间没有直接关系，它们的联系完全是通过主模块的控制和调用来实现的。

　　数据耦合:两个模块彼此间通过数据参数交换信息。

　　标记耦合:一组模块通过参数表传递记录信息，这个记录是某一个数据结构的子结构，而不是简单变量。

　　控制耦合:两个模块彼此间传递的信息中有控制信息。

　　外部耦合:一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息。

　　公共耦合:两个模块之间通过一个公共的数据区域传递信息。

　　内容耦合:一个模块需要涉及到另一个模块的内部信息。

# 软件测试

一条Bug包括编号、Bug描述、Bug级别、Big所属模块、发现人

![5eca3baaa8356](http://www.kokojia.com/Public/images/upload/article/2020-05/5eca3baaa8356.png)

各测试阶段的任务：

　　(1)验收测试：有效性测试、软件配置审查、验收测试。

　　(2)系统测试：恢复测试、安全性测试、强度测试、性能测试、可靠性测试和安装测试。

　　(3)集成测试：模块间的接口和通信。

　　(4)单元测试：模块接口、局部数据结构、边界条件、独立的路径、错误处理。

　　(5)其他测试：回归测试(修改软件后进行的测试，防止引入新的错误)。负载测试(对软件负载能力的测试)。压力测试(对软件超负荷条件下运行情况的测试)。

# 系统测试

- 安全测试
- 回复测试
- 性能测试
- 强度测试

# 成本估算

**专家估算**

根据专家的行业经验和历史数据对软件开发过程的成本进行估算

**Wolverton**

通过执行的源代码函数来进行成本估算,估算准确度低.已不用

**COCOMO**

构造性成本模型,是一种参数化的成本估算方法

**COCOMO2**

COCOMO基础上,把最新软件开发方法考虑在内,由三个计算模型组成

- 应用组合模型
- 早期开发模型
- 结构化后期模型

# McCabe复杂度

1、McCabe复杂度计算公式：V(G)=m-n+2，其中m是有向弧的条数，n是结点数。

2、对于伪代码可以先转换为程序流程图，对程序流程图可以最终转换为结点图处理，转换时注意将交点的地方标注为新的结点，以最终的结点图带入公式结算其McCabe复杂度。

# 软件维护

1、更正性维护：针对真实存在并**已经发生**的错误进行的维护行为。

　　2、预防性维护：针对真实存在但还**未发生**的错误进行的维护。

　　3、适应性维护：指使应用软件适应信息技术变化和管理需求变化而进行的修改。企业的外部市场环境和管理需求的不断变化也使得各级管理人员不断提出新的信息需求。

　　4、完善性维护：扩充功能和改善性能而进行的修改。对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。

# 软件质量保证

![5eca3bf75fc14](http://www.kokojia.com/Public/images/upload/article/2020-05/5eca3bf75fc14.png)

# 软件过程改进

http://www.kokojia.com/article/43433.html

# Gantt图与Pert图

Ganntt图

优点:

能够清晰地描述每个任务从何时开始,到何时结束以及各个任务之间的并行性

缺点:

不能清晰地反映出任务之间的依赖关系,难以确定整个项目的关键所在,也不能反映计划中有潜力的部分

# 风险管理

1. 风险的特性:具有不确定性,可能会造成损失
2. 风险的类别:项目风险涉及到各种形式的预算、进度、人员、资源以及客户相关的问题,并且可能导致项目损失.技术风险涉及到技术相关的可能会导致项目损失的问题.商业风险与市场因素相关.社会风险涉及到政策、法规等因素
3. 风险暴露又称风险曝光度,测量的是资产的整个安全性风险,它将表示实际损失的可能性与表示大量可能损失的资讯结合到单一数字评估中.在形式最简单的定量性风险分析中,风险曝光度课透过将风险可能性及影响相乘算出

风险曝光度=错误出现率(风险出现率)*错误造成损失(风险损失)

https://www.cnblogs.com/vanjob/articles/6391065.html

# 面对对象的概念

1、基本概念：

　　(1)对象：属性(数据)+方法(操作)+对象ID。

　　(2)类：(实体类/控制类/边界类)。

　　(3)接口：一种特殊的类，他只有方法定义没有实现。

　　(4)封装：隐藏对象的属性和实现细节,仅对外公开接口，是一种信息隐藏的机制。

　　(5)多态：不同对象收到同样的消息产生不同的结果。多态实质上是将子类的指针对象或者引用对象传递给父类指针对象后，通过这个父类指针对象调用的函数(此函数在父类中声明为虚函数，且在各个子类中重写这个函数)，不是父类中定义的，而是传递进来的子类对象中重写的函数。

　　过载多态：同一个名(操作符﹑函数名)在不同的上下文中有不同的类型。

　　(6)重载：一个类可以有多个同名而参数类型不同的方法。

　　(7)继承与泛化：复用机制。面向对象技术中，继承是父类和子类之间共享数据和方法的机制。这是类之间的一种关系，在定义和实现一个类的时候，可以在一个已经存在的类的基础上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。可以存在多重继承的概念，但不同的程序设计语言可以有自己的规定。

　　(8)消息和消息通信：消息是异步通信的。

　　2、面向对象设计原则：

　　(1)单一职责原则：设计目的单一的类。

　　(2)开放-封闭原则：对扩展开放，对修改封闭。

　　(3)李氏(Liskov)替换原则：子类可以替换父类。

　　(4)依赖倒置原则：要依赖于抽象，而不是具体实现;针对接口编程，不要针对实现编程。

　　(5)接口隔离原则：使用多个专门的接口比使用单一的总接口要好。

　　(6)组合重用原则：要尽量使用组合，而不是继承关系达到重用目的。

　　(7)迪米特(Demeter)原则(最少知识法则)：一个对象应当对其他对象有尽可能少的了解。

# UML

![img](https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZDJmOTFmZTYtMjJiYy00ZDczLWExNWEtOWIwZDI4ZTE5MzI2IiwicmVzb3VyY0d1aWQiOiI0OGMzNjlhNi1jNjIyLTQxMzktODNmYi05YmM4NjA4YzMxNDUifQ==)

# 设计模式

# 数组与矩阵

![5eca3ddbc94b5](http://www.kokojia.com/Public/images/upload/article/2020-05/5eca3ddbc94b5.png)

# 线性表

1、顺序表和链表的对比：

　　

![img](http://www.kokojia.com/Public/images/upload/article/2020-03/5e5d10bb88190.png)

 

　　2、顺序表：线性表顺序存储，即用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素，在物理上也相邻。在存储之前，先根据线性表的长度分配连续的物理空间，因此后续不方便扩展。只需要存储数据元素，不需要存储元素的逻辑关系因此存储密度为1。

　　3、链表：线性表链式存储，即用通过指针链接起来的结点来存储数据元素，存储各数据元素的结点物理上不要求连续，因此后期扩展方便。因为物理上不连续，需要同时存储各元素之间的逻辑关系，存储密度小于1。

　　4、链表的分类：单链表、双链表、循环链表。

　　5、特殊的线性表：队列(先进先出)、栈(先进后出)。

　　6、循环队列：

　　队空条件：head=tail

　　队满条件：(tail+1)%size=head

# 广义表

1、广义表是n个表元素组成的有限序列，是线性表的推广。

　　2、通常用递归的形式进行定义，记做：LS=(a0, a1,…, an)。

　　注：其中LS是表名，ai是表元素，它可以是表(称做子表)，也可以是数据元素(称为原子)。其中n是广义表的长度(也就是最外层包含的元素个数)，n=0的广义表为空表;而递归定义的重数就是广义表的深度，直观地说，就是定义中所含括号的重数(原子的深度为0，空表的深度为1)。

　　3、基本运算：取表头head(Ls)和取表尾tail(Ls)。

　　取表头head(Ls)，非空广义表的Ls的第一个元素称为表头，它可以是一个单元素，也可以是一个子表。

　　取表尾tail(Ls)，非空广义表Ls，除表头元素之外，由其余元素所构成的表称为表尾。非空广义表的表尾必定是一个表。

　　若有：LS1=(a，(b，c)，(d，e))

　　head(LS1)=a

　　tail(LS1)=((b，c)，(d，e))

# 树与二叉树

# 图

# 排序与查找

# 复杂度与空间复杂度

# 算法基础及常见算法

# 编译与解释

1、解释程序，也称解释器;直接解释执行源程序，或者将源程序翻译成某种中间代码后再加以执行。

　　2、编译程序，也称编译器;将源程序翻译成目标语言程序，然后再计算机上运行目标程序。

　　3、两者的根本区别：编译方式下，机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程，因此执行时效率较高;解释方式下，解释程序和源程序(或某种等价表示)要参与到程序的运行过程中，运行程序的控制权在解释程序，边解释边执行，执行效率较低。即：解释方式，翻译程序不生成独立的目标程序，而编译方式则生成独立保持的目标程序。

　　4、编译过程：

　　(1)词法分析阶段：是编译过程的第一阶段，其任务是对源程序从前到后(从左到右)逐个字符扫描，从中识别出一个个“单词”符号。词法分析过程的依据是语言的词法规则，即描述“单词”结构的规则。

词法分析的作用是识别源程序中的记号

　　词法错误：非法字符，关键字或标识符拼写错误。

　　(2)语法分析阶段：其任务是在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单位。通常语法分析是确定整个输入串是否构成一个语法上正确的程序。一般来说，通过编译的程序，不存在语法上的错误。

　　语法错误：语法结构出错，if　endif不匹配，缺分号。

　　(3)语义分析阶段：其任务主要检查源程序是否包含静态语义错误(动态语义错误在执行过程中才能发现)，并收集类型信息供后面的代码生成阶段使用。语义分析的一个主要工作是进行类型分析和检查。

静态语义分析方法是**语法制导翻译**

　　语义错误：死循环，零除数，其它逻辑错误。

　　(4)中间代码生成：其任务是根据语义分析的输出生成中间代码。**此阶段不是必须的**。常见的中间代码有：**树、后缀式、三地址码(四元式)**。

　　(5)代码优化：其任务是优化中间代码。**此阶段不是必须的**。

　　(6)目标代码生成：是**编译器工作**的最后一个阶段。其任务是把中间代码变换成特定机器上的绝对指令代码、可重定位的指令代码或汇编指令代码。本阶段与具体机器密切相关。

　　

![img](http://www.kokojia.com/Public/images/upload/article/2020-05/5eca4027bd9d2.png)

 

　　(7)符号表的作用是记录源程序中各个符号的必要信息，以辅助语义的正确性检查和代码生成，在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。符号表的存在可以贯穿编译所有阶段。

# 文法

# 正规式

| 正规式    | 正规集                     |
| --------- | -------------------------- |
| a         | {a}                        |
| a\|b      | {a,b}                      |
| ab        | {ab}                       |
| ab(a\|b)  | {aba,abb}                  |
| a^*^      | {空集,a,aa,...}            |
| (a\|b)^*^ | {空集,a,b,aa,ab,bb,ba,...} |



# 有限自动机(DFA)

# 后缀表达式

# 传值与传址

# 系统

为了优化系统性能,有时需要对系统进行调整.对于数据库系统,性能调整主要包括CPU/内存使用状况、优化数据库设计、优化数据库管理以及进程/现成状态、硬盘剩余空间、日志文件大小等;对于应用系统,性能调整主要包括应用系统的可用性、响应时间、并发用户数以及特定应用的系统资源占用等

# 嵌入式系统

系统初始化过程以软件初始化为主,主要进行操作系统的初始化

嵌入式系统设计时,高速缓存对程序员是透明的

# 音频

**动态影像专家小组**（英语：**M**oving **P**icture **E**xperts **G**roup，简称**MPEG**）为一源自ISO与IEC等国际组织的工作小组，用以制定影音压缩及传输的规格标准。

![Mpeg](https://upload.wikimedia.org/wikipedia/commons/5/5b/Mpeg.svg)

MPEG-7是多媒体内容描述的接口标准

MPEG-21是多媒体应用框架标准

**格式**

WAV、MP3、AIF

改变载波频率相当于改变音调,改变信号幅度(强度)相当于改变音高

人耳能听到的音频信号的频率范围是20Hz~20KHz

# 视频

**格式**

MPG

# 文本

**格式**

RTF

# 媒体

**感觉媒体**

一般是指人们接触信息的感觉形式，使人产生直接感觉(视、听、嗅、味、触 觉)的媒体，如语言、音乐、各种图像、图形、动画、文本等

**表示媒体**

指信息的表示形式，而且该媒体是为了感觉媒体而被人们研究出来的，如语言编码、电报码、条形码、语言编码，静止和活动图象编码以及文本编码等

**表现媒体**

表现和获取信息的物理设备。其又可以分为两类：一是输入显示媒体键盘，鼠标和麦克风；二是输出显示媒体显示器，打印机和音箱

**存储媒体**

存储数据的物流设备，如磁盘，光盘和内存等

**传输媒体**

传输数据的物理载体，如：电缆，光缆和交换设备等

# 图像



# 知识产权

职务作品:除著名权外,著作权(版权)的其他权利由公司享有

申请专利:谁先申请谁获得,同时申请协商获得

申请商标:谁能证明先用谁获得,否则协商或抽签

著作权:著作权归属有委托人和受托人通过合同约定,合同中未明确约定的,著作权属于受托人

专利权归属:

- 在本职工作中做出的发明创造
- 旅行社本单位交付的本职工作之外的任务所做出的发明创造
- 退职、退休或者调动工作后1年内所做出的,与其在原单位承诺的本职工作或者单位分配的任务有关的发明创造

均归原公司所有

任何争议基本上先找主管行政管理部门进行仲裁,仲裁不成功再进行诉讼

计算机软件的著作权的保护对象是指计算机程序及其文档

软件商标权的权利人是指软件注册商标的所有人

商标权可以续期

商标发音和功能相近,存在侵权风险,只能留一个

商业秘密权用来保护商家的秘密

《计算机软件保护条例》由国务院颁布

保护期不受限:著名、修改、保护作品完整权

保护期为作者终身及死后50年:发表权、使用权、获得报酬权

《中华人民共和国著作权法》《和计算机软件保护条例》是构成我国保护计算机软件著作权的两个基本法律

必须使用注册商标的是烟草类商品

# 英语

| 英文            | 中文     |
| --------------- | -------- |
| E-commerce      | 电子商务 |
| Object-oriented | 面向对象 |
| approach        | 方法     |



# RAM

**DRAM**

读破坏,主存采用该结构

**SRAM**

速度比DRAM快,一般cache存储器采用该结构

# 其他

COBOL不是脚本语言

微程序一般由硬件执行

c程序中全局变量储存空间在静态数据区分配

VLIW是超长指令子的简称

DPI表示单位”像素/英寸“

程序设计语言基本采用上下文无关文法

尼奎斯特取样定理:取样速率大于模拟型号最高频率的2倍,则可以得到样本中恢复原来的模拟信号

虚拟存储体系由主存-辅存两级存储器构成

低级程序语言面向机器的语言 高等程序设计语言不依赖与具体的机器硬件

小型和微型计算机系统中普遍采用的字符编码是ASCII码

计算机性能参考指标:吞吐率、响应时间、资源利用率

固态硬盘:存储介质是闪存芯片,比机械硬盘功耗低

相联存储器

PPP的NCP可以承载多种协议的三层数据包,PPP使用LCP控制多种链路的参数,PPP的pap认证是通过二次握手建立认证,PPP的chap挑战握手认证协议,通过三次握手认证,PPP的双向验证,采用的是chap的主验证风格,PPP的加固验证,采用的是两种PAP、CHAP验证

VPN关键技术隧道技术、加解密技术、密钥管理技术和身份认证技术

4G 100M 5G 10G

主机路由子网掩码255.255.255.255

语法分析器接受以单词为单位的输入,并产生有关信息以供以后个阶段使用,LR分析法和递归下降法是几种常见的语法分析技术.LR分析法主要有SLR(1)、LR(0)、LR(1)和ALR(1)等4种,其中LR(1)的分析能力最强,LR(0)分析能力最弱

若系统在将索引结点、目录快、空闲快文件修改的结果写会磁盘时发生崩溃,则对系统的影响相对较大

中断可分为不可屏蔽中断和可屏蔽中断

多线程的操作系统中,程序计数器,寄存器,栈不能共享

正式技术评审的目标是发现软件中的错误
